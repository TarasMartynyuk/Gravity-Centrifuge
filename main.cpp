#include <iostream>
#include <string>
#include <utility>
#include <vector>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <sstream>
#include <iterator>
#include <bitset>

using namespace std;

// is trivially copyable, does not own the pointers for now
class Landscape {
public:
    Landscape(vector<int>* row_block_counts, vector<int>* col_block_counts)
        : row_block_counts(row_block_counts), col_block_counts(col_block_counts) {
        assert(columnsRowsHaveEqualBlocksCount());
    }

    int rows()const { return row_block_counts->size(); }
    int columns()const { return col_block_counts->size(); }

    // updates row blocks counts to simulate blocks falling to the bottom
    void simulateFall() {
        for (int i = rows() - 1; i >= 0; --i) {
            // how much blocks must the column have
            // so that when blocks fall one will be placed in the ith row
            int thresh = rows() - i;
            int row_blocks = countColumnsWithNotLessBlocksThan(thresh);
            row_block_counts->at(i) = row_blocks;
        }
        assert(columnsRowsHaveEqualBlocksCount());
    }

    // returns the landscape that is created by rotating this by 90 deg counter-clockwise
    // its dims are swapped
    Landscape rollOver()const {
        auto* rotated_col_block_counts = row_block_counts;

        auto* rotated_row_block_counts = new vector<int>(col_block_counts->size());
        for (int i = 0; i < col_block_counts->size(); ++i) {
            int reverse = col_block_counts->size() - 1 - i;
            rotated_row_block_counts->at(reverse) = col_block_counts->at(i);
        }
        return { rotated_row_block_counts, rotated_col_block_counts};
    }

    // outputs the landscape to grid
    // assumes that all the blocks have already fallen to bottom,
    // thus ignores the row_block_counts values
    vector<vector<char>> toGrid()const {
        vector<vector<char>> grid(rows(), vector<char>(columns(), '%'));

        for (int j = 0; j < columns(); ++j) {
            int blocks_for_col = col_block_counts->at(j);
            for (int i = 0; i < rows(); ++i) {
                int row_from_bot = rows() - i;
                char ch = row_from_bot <= blocks_for_col ?
                          '#' : '.';
                grid.at(i).at(j) = ch;
            }
        }
        return grid;
    }


private:
    //TODO: implement proper block count array ownership
    // row : # blocks in that row
    vector<int>* row_block_counts;
    // col : # blocks in that col
    vector<int>* col_block_counts;

    int countColumnsWithNotLessBlocksThan(int thresh) {
        return count_if(col_block_counts->begin(), col_block_counts->end(),
                        [thresh](int blocks) {
                            return blocks >= thresh;
                        });
    }

    bool columnsRowsHaveEqualBlocksCount() {
        return accumulate(row_block_counts->begin(), row_block_counts->end(), int()) ==
               accumulate(col_block_counts->begin(), col_block_counts->end(), int());
    }
};

class LandscapeTumbler {
public:
    LandscapeTumbler(Landscape init_landscape) : init_landscape(init_landscape) {}

    // returns the landscape after the tumblings
    const Landscape& tumble(int times) {
        assert(times > 0);
        return tumble(times % 2 == 0);
    }

    // we can;t handle the 0 tumbles case in this overload
    const Landscape& tumble(bool tumble_count_even) {
        if (odd_state == nullptr) {
            computeOddAndEvenStates();
        }

        return *(tumble_count_even ?
                 even_state : odd_state);
    }

private:
    const Landscape init_landscape;
    // the landscapes produced by tumbling cycle after first two -
    // so every even and odd state are same
    Landscape* odd_state{};
    Landscape* even_state{};
//    Landscape* curr_state{};

    void computeOddAndEvenStates() {
        odd_state = new Landscape(init_landscape.rollOver());
        odd_state->simulateFall();

        even_state = new Landscape(odd_state->rollOver());
        even_state->simulateFall();
    }
};

class CentrifugeSimulator {
public:
    bool total_tumbles_even{true};
    ulong long drive_a_momentum{1};
    ulong long drive_b_momentum{1};

    static const int kPortionSize = 54;

    // interprets the 18 (max even number of full 3-bit pairs that fits into long - one for each oct digit)
    // lowest bits of six_bit_command
    // as a series of commands to centrifuge's drives
    // one command is 2 bits - first for drive A, second for drive B
    void processFullCommandPortion(ulong long commands_portion_number) {
//        assert(hasNoMoreLowestBitsThanCommandPortion(commands_portion_number));
        bitset<kPortionSize> command_portion(commands_portion_number);

        for (int i = 0; i < kPortionSize - 1; i += 2) {
            bool drive_a_tumbles = command_portion.test(i);
            bool drive_b_tumbles = command_portion.test(i + 1);

            ulong long tumbles_performed = operateBothDrives(drive_a_tumbles, drive_b_tumbles);
            recalculateTotalTumblesEven(tumbles_performed);
        }
    }

    // processes command that is less in size than full portion
    void processLeftoverCommandPortion(ulong long commands_portion_number, int bits_left) {
        //TODO: process only part of the bits instead of full portion
        processFullCommandPortion(commands_portion_number);
    }

private:
    ulong long operateBothDrives(bool drive_a_tumbles, bool drive_b_tumbles) {
        ulong long a_tumble_count = operateDrive(drive_a_tumbles, drive_a_momentum, drive_b_momentum);
        ulong long b_tumble_count = operateDrive(drive_b_tumbles, drive_b_momentum, drive_a_momentum);
        return a_tumble_count + b_tumble_count;
    };

    ulong long operateDrive(bool tumbles, ulong long& drive_momentum, ulong long& idle_drive_momentum) {
        idle_drive_momentum += drive_momentum;
        return tumbles ? drive_momentum : 0;
    }

    void recalculateTotalTumblesEven(ulong long tumbles_performed) {
        bool tumble_count_even = tumbles_performed % 2 == 0;
        total_tumbles_even = total_tumbles_even == tumble_count_even;
    }

    // true if the numbers highest set bit is not out of bounds of what
    // a number with bits_per_command_portion bits can represent
    bool hasNoMoreLowestBitsThanCommandPortion(unsigned long number) {
        bitset<55> portion_bound;
        portion_bound.set(portion_bound.size() - 1);

        return portion_bound.to_ulong() > number;
    }
};

bool tumblingsCountEven(const string& centrifuge_command) {
    CentrifugeSimulator centrifuge;
    const int oct_digits_in_command_portion = 6;
    auto full_portions = static_cast<int>(centrifuge_command.size() / oct_digits_in_command_portion);

    auto index = static_cast<int>(full_portions == 0 ?
                                 centrifuge_command.size() : centrifuge_command.size() - 3);

    for (int portion = 0; portion < full_portions; ++portion, index -= 3) {
        assert(index >= 0);

        auto three_oct_digits =  centrifuge_command.substr(index, 3);
        assert(three_oct_digits.size() == 3);

        ulong long three_oct_digits_num = strtoull(three_oct_digits.c_str(), nullptr, 8);
        centrifuge.processFullCommandPortion(three_oct_digits_num);
    }

    // now index is after the last full portion (going right -> left)
    auto portion_leftover = centrifuge_command.substr(0, index);
    ulong long portion_leftover_num = strtoull(portion_leftover.c_str(), nullptr, 8);
    centrifuge.processLeftoverCommandPortion(portion_leftover_num, static_cast<int>(portion_leftover.size() * 3));

    return centrifuge.total_tumbles_even;
}

int main()
{
    //region mock
//    stringstream cin;
//    cin << "53 5\n"
//           "505652414137127430050061125664475326341116327547300377112354014317113473570134367202412146212504153057517554675615056041622546635025451025451706002113556010243454157703247533332373777662107172265213600665521076257434673756577702237456624505026072033545047525032463715035436566730554763240336775100477056053345253277521744704170007615205170243762601513745755200420503644505364520517040062266153502656164670532427107076371075157267350165752407701175423013566120275206710307461544627165762557110533351102650423601306027715032335625563300051126473366205707357755356013630124133021554041000444047567615013656054452417653460501327475734457054640432136506701445013065701640423650643311066423570361646770366621336101253264073776717100015225433420677703543327347761771633356505343127254143610004447262772742146722076316524661734210003160160171621306642352036345136171702475076171555111377400622065367406437232076741143370210231230407642061730617070036105570624175070763336522124713456660677053613700040723474023544372725412360160317424433230005655513756001677736307470161543631641211326302352776173216142152740747433402063306330403243201164202703737174667361314577453111604261371145434157141426755636155252047612665632257405777022670530406261041544031427763042725402266017511730712057272366335063016531150102434657404261307713515057645515540546273502543707605660005511311231115507427114502642377052333573664650027072335675305040035274333225205514241365557350452276465422400600011654370317302655541461262505742541175446145647142562556455642435565606305763517173744552425023164715210266200661230403754414531343776513513462247000626623322266134476345612434630360676015350731633256224664054643003106134151637061312706461156043231545654120626354330641330574467423161743520426755417465761141617031473244761642454756711335715246300754760334563621523277626754227317464573607377371276565711512154227302753402401416377253620354522066135564573141614466530217002203331465766000126244554420671300252504223513367330244704334532013214260516134111627026655273015723717623451661553303166163154064552462322345440350311015070037150372323136534546211521374304256331022504105257744326062440661440225752751200246073577247355121652444002620665213715356326476720633346266524751200033615022563575535010046470426343507113444324611721135112711735634032734565620013474571567724771066643612206560040275346711262441127622631762074212622151232070545374166653472615373174474306261413153213652220573327022452323167132150147657712475204137470663206425110505140614133674030306153600204376131747154655705344651315454742375117657160115000325173426414577124162235204056506025662110117217177130533273535724425533046253303576465136627673226631771631532257363272103422542554002741107325123200443767325435123371413150765420622202115752377525314460403406705604241505035265140461603224363641665050450477225247466711235004110666762406643231275412323160702067417346530612132453430301745151421100007310644334213234034614714345256471775456043275614760426656110576105173131555500252202045067102036164756653356312570403354061562163622752617250127163564665650762034324570313020057037773405644641622136132662302304755727445731075624641324615167527107662421675700200323162731557744272244774060211315546173602242357421560717602001354534005164416410500042017504045312347675465530515525721030733741630674240445477105363607556760105765275125361740037470210016067760743220305234473540645715075727274464277727173106760706453734125237573047545077315736231255012055421475103346652501026755041743607024126262341543604624271261263110353706027445067554205653145223762131725565236173144104056513051361451305315143326626345045177643775131744115626701600447313137521300534053104060330704765701753412541506414776627751466440255243541305243135341300613272325616611645004573432217677523316324137264457406414543510736603716533452457451721422272374112215771335021104435552542371020447003445356444020372257163547467555732421457027114444030326740563504777352104033573626321146317751043327563104537271335644704012643676764010425144053550100376424503127046460434447516331211727100076051764470410454211632731176650505327427160012730020750566144375700637066374763115716671113741245302540610545600451257645276044011710776670220557765631211165336427051471176556544533000775443255354577551216743015757235764561710705143433007227733163365225064752230676516074504341524620312776375017165346137771742771772630760460103343147411105420510356514502571144635052425250006606012027720132000602431351052652607415340754374162753141471061414600457714544071572463202673503441327152045120350324135045271307253127456441163625652535742234456030160432275452103354340567517064075572470520655552671254677631714463057543030705455222070035721374770643066105340222662770637317605571414115453712136310212602316421653366210125272731674262274727602212520403005460213202736655752727626542042660303734354472515172700026271614204404401274317401037344336540437376160765641452177543602722520273425336676073750347101571706406172204351145317514553025523451446333641615154734015645053600677014013677173041137722371162121277004542516205054515524126661155570461065736161602174535315730312165055727642210261623733520700514770517461211034670200726603453077425176777363466157560631374247246631353051064563020651626223454472235622506050046367660516372571324464446117535055253366007523423112415046661527560373664350177155555173110206132742712036432653555237160704645647136240775240467043100353001434552672740356264114022735654271704143330430436252621171775134376534635465333475272757327004425721171677155104071452230320636557034211026474766541623331433302527033753463527767146021473613254657604611764376051223461771530153232747660456414670231705504207477470640021075045272451760422731217162134241366220302754617670507266551443200075155611764376377154667013242272502320324425641751624505233622010703241314410753106142415645164276204640440633330227727005006104401405460652155353342306363070206415257473000225561563620507754761225034604616000575715462150027147274064462364326614453642301220222631250522707275167525033050666620570357753141362536077620100156476513752723645434050776672363376415413501770311212303673051435730340442251105642645774765011275235103013103605426241637434663555642126255435773633350635501714356443715501306042226233776672651311235607453477410675434550100541170364127345612736271753020524733600054150070234347055430550554762406117072756174074160546263631014501436411310673057476336103424076124542467046360252400636611200541573744244236533670247457000642323140321660545251156412407126014012427025151622673242164271255043626401345165765423060454352665234660760352654355400675111105612311643700105553306646573233540701616350207556457555231375155064106242255746721314210735270533304737075300020011372004375140617674363503576671642145461473243671774457050544652756602051406254015777305671374274003605451535600612041775414407717002741330336320321441503121165164132230417775216316603735165230443710324640733616240621660023335763036212335605420447264621666070366525266523201370602221030145052750354602342522270617054425263457604531200145505567241636423447647157047777672623254351537752343255122174025440315407564501322461056476670144304603446741546200710042513043722501426301003454352475536260356523775101117312526137303622207631456442274661604343066730504641254371733571406253747306202516372566166621150216447520320430511125205534237104065241564653344045571341166234274371667200775365302324620656156721710703536235705133235345070505746027476664110403733144266657571272564577574135171266413024514263657442724740134221075242746572045626663123571106236014511007276512634514743706505761501400713704024564330451731446774012226626640023402245756472733101201350460710626235354442465741704202563773611232301765535440075043557236357767532147077755516570321746660143513402536435135737032622042473317220432037774346657213447733376703005632140452315707740252046406504051771420713655616744060177722347004147111326611244335767525113222270601476410067323332556045767371077444776360440425037304630161343416017675351253011324252535363277146241166030143636714056017326646272110366721031050227363570142520562634660236507345025561361623744306524672064640744663306662643020233023527164176047107751420464046645010642311302435333565104111175562337550274006605721141673765011443631147617173147260350027037100313177050372100071620151632563076334053313252437467734776476553026047766602532314777473154634251621255161154213565311205506140575202510033207232522551333366562736156504456034156174605067377631150543360075507351575431156742622500365672717140761457142665732136201326517162062742254242273756441150025761114645502730237766070645033630147237671665047040600223137235736357354611742010633325257604137703557027343472744406032115646744701537655345045466751016042722434723052202174266235132667066613141116234037263365505543557144705070474334576636400626604700122533776221711337615416711314205610147131162234575327317204065416004536557366223775230533662062427623352671541211004250015435730734146652064420520207330752062633510630060237712646215114270306057130175255456232051534171170565265325417417341074442146111332676726570604263051721006644261155547343015146615676724570045512406172214571003040771447205511277014127432443620323212500135742040726515667113473074446342176355572542570511263637701665231717336165656121321424557045655077723737403152440561663365140670567547544105024132614072671601333554363205376125266113245006712044001374564176536355442757422055062712654633252726542554721065264565732264335151255251050500103531672334521060522356665063412041641367046221353434152724725263731061165732353730115105440575511446052205371664760274541125360710367151635112401\n"
//           "#.....#...#.#.......#...#...#.#.....#...#.#...#.#....\n"
//           "#.....#...#.#.......#...#...#.#..#..#...#.#...#.#....\n"
//           "#.....#...#.#...#...#...#...#.#.##..#...#.#...#.###..\n"
//           "#####.#####.#####.#####.#...#.#####.#####.#...#.#####\n"
//           "#####.#####.#####.#####.#####.#####.#####.#####.#####";
    // stringstream cin;
    // cin << "17 5\n"
    //       "1\n"
    //       ".................\n"
    //       ".................\n"
    //       "...##...###..#...\n"
    //       ".####..#####.###.\n"
    //       "#################";

    //endregion

    int columns;
    int rows;
    cin >> columns >> rows; cin.ignore();
    string centrifuge_command; getline(cin, centrifuge_command);
//    int tumblings_count; cin >> tumblings_count; cin.ignore();

    auto* row_block_counts = new vector<int>(rows, 0);
    auto* col_block_counts = new vector<int>(columns, 0);

    for (int i = 0; i < rows; i++) {
        string tile_row; getline(cin, tile_row);

        for (int j = 0; j < columns; ++j) {
            if(tile_row.at(j) == '#') {
                row_block_counts->at(i)++;
                col_block_counts->at(j)++;
            }
        }
    }
    //endregion

    Landscape init_landscape(row_block_counts, col_block_counts);
    Landscape& result_landscape = init_landscape;
    if(centrifuge_command != "0") {
        LandscapeTumbler tumbler(init_landscape);

        bool tumblings_count_even = tumblingsCountEven(centrifuge_command);

        result_landscape = tumbler.tumble(tumblings_count_even);
    }

    auto landscape_char_grid = result_landscape.toGrid();

    ostream_iterator<char> os_it(cout, "");
    for(auto& row : landscape_char_grid) {
        copy(row.begin(), row.end(), os_it);
        cout << "\n";
    }
}

