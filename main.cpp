#include <iostream>
#include <string>
#include <utility>
#include <vector>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <sstream>
#include <iterator>
#include <bitset>

using namespace std;

// is trivially copyable, does not own the pointers for now
class Landscape {
public:
    Landscape(vector<int>* row_block_counts, vector<int>* col_block_counts)
        : row_block_counts(row_block_counts), col_block_counts(col_block_counts) {
        assert(columnsRowsHaveEqualBlocksCount());
    }

    int rows()const { return row_block_counts->size(); }
    int columns()const { return col_block_counts->size(); }

    // updates row blocks counts to simulate blocks falling to the bottom
    void simulateFall() {
        for (int i = rows() - 1; i >= 0; --i) {
            // how much blocks must the column have
            // so that when blocks fall one will be placed in the ith row
            int thresh = rows() - i;
            int row_blocks = countColumnsWithNotLessBlocksThan(thresh);
            row_block_counts->at(i) = row_blocks;
        }
        assert(columnsRowsHaveEqualBlocksCount());
    }

    // returns the landscape that is created by rotating this by 90 deg counter-clockwise
    // its dims are swapped
    Landscape rollOver()const {
        auto* rotated_col_block_counts = row_block_counts;

        auto* rotated_row_block_counts = new vector<int>(col_block_counts->size());
        for (int i = 0; i < col_block_counts->size(); ++i) {
            int reverse = col_block_counts->size() - 1 - i;
            rotated_row_block_counts->at(reverse) = col_block_counts->at(i);
        }
        return { rotated_row_block_counts, rotated_col_block_counts};
    }

    // outputs the landscape to grid
    // assumes that all the blocks have already fallen to bottom,
    // thus ignores the row_block_counts values
    vector<vector<char>> toGrid()const {
        vector<vector<char>> grid(rows(), vector<char>(columns(), '%'));

        for (int j = 0; j < columns(); ++j) {
            int blocks_for_col = col_block_counts->at(j);
            for (int i = 0; i < rows(); ++i) {
                int row_from_bot = rows() - i;
                char ch = row_from_bot <= blocks_for_col ?
                          '#' : '.';
                grid.at(i).at(j) = ch;
            }
        }
        return grid;
    }


private:
    //TODO: implement proper block count array ownership
    // row : # blocks in that row
    vector<int>* row_block_counts;
    // col : # blocks in that col
    vector<int>* col_block_counts;

    int countColumnsWithNotLessBlocksThan(int thresh) {
        return count_if(col_block_counts->begin(), col_block_counts->end(),
                        [thresh](int blocks) {
                            return blocks >= thresh;
                        });
    }

    bool columnsRowsHaveEqualBlocksCount() {
        return accumulate(row_block_counts->begin(), row_block_counts->end(), int()) ==
               accumulate(col_block_counts->begin(), col_block_counts->end(), int());
    }
};

class LandscapeTumbler {
public:
    LandscapeTumbler(Landscape init_landscape) : init_landscape(init_landscape) {}

    // returns the landscape after the tumblings
    const Landscape& tumble(int times) {
        if(odd_state == nullptr) {
            computeOddAndEvenStates();
        }

        return *(times % 2 == 0 ?
               even_state : odd_state);
    }


private:
    const Landscape init_landscape;
    // the landscapes produced by tumbling cycle after first two -
    // so every even and odd state are same
    Landscape* odd_state{};
    Landscape* even_state{};
//    Landscape* curr_state{};

    void computeOddAndEvenStates() {
        odd_state = new Landscape(init_landscape.rollOver());
        odd_state->simulateFall();

        even_state = new Landscape(odd_state->rollOver());
        even_state->simulateFall();
    }
};

class CentrifugeSimulator {
public:
    long total_tumbles = 0;
    int drive_a_momentum = 1;
    int drive_b_momentum = 1;

    static const int kPortionSize = 54;

    // interprets the 18 (max even number of full 3-bit pairs that fits into long - one for each oct digit)
    // lowest bits of six_bit_command
    // as a series of commands to centrifuge's drives
    // one command is 2 bits - first for drive A, second for drive B
    void processFullCommandPortion(long long commands_portion_number) {
//        assert(hasNoMoreLowestBitsThanCommandPortion(commands_portion_number));
        bitset<kPortionSize> command_portion(commands_portion_number);

        for (int i = 0; i < kPortionSize - 1; i += 2) {
            bool drive_a_tumbles = command_portion.test(i);
            bool drive_b_tumbles = command_portion.test(i + 1);

            operateBothDrives(drive_a_tumbles, drive_b_tumbles);
        }
    }

    // processes command that is less in size than full portion
    void processLeftoverCommandPortion(long commands_portion_number, int bits_left) {
        //TODO: process only part of the bits instead of full portion
        processFullCommandPortion(commands_portion_number);
    }

    void operateBothDrives(bool drive_a_tumbles, bool drive_b_tumbles) {
        operateDrive(drive_a_tumbles, drive_a_momentum, drive_b_momentum);
        operateDrive(drive_b_tumbles, drive_b_momentum, drive_a_momentum);
    };

    void operateDrive(bool tumbles, int& drive_momentum, int& idle_drive_momentum) {
        if(tumbles) {
            total_tumbles += drive_momentum;
        }
        idle_drive_momentum += drive_momentum;
    }

    // true if the numbers highest set bit is not out of bounds of what
    // a number with bits_per_command_portion bits can represent
    bool hasNoMoreLowestBitsThanCommandPortion(unsigned long number) {
        bitset<55> portion_bound;
        portion_bound.set(portion_bound.size() - 1);

        return portion_bound.to_ulong() > number;
    }
};

long getNetTumblingsCount(const string& centrifuge_command) {
    CentrifugeSimulator centrifuge;
    const int oct_digits_in_command_portion = 6;
    int full_portions = centrifuge_command.size() / oct_digits_in_command_portion;

    int index = full_portions == 0 ?
                centrifuge_command.size() : centrifuge_command.size() - 3;

    for (int portion = 0; portion < full_portions; ++portion, index -= 3) {
        assert(index >= 0);

        auto three_oct_digits =  centrifuge_command.substr(index, 3);
        assert(three_oct_digits.size() == 3);

        long long three_oct_digits_num = strtoll(three_oct_digits.c_str(), nullptr, 8);
        centrifuge.processFullCommandPortion(three_oct_digits_num);
    }

    // now index is after the last full portion (going right -> left)
    auto portion_leftover = centrifuge_command.substr(0, index);
    long long portion_leftover_num = strtoll(portion_leftover.c_str(), nullptr, 8);
    centrifuge.processLeftoverCommandPortion(portion_leftover_num, portion_leftover.size() * 3);

    return centrifuge.total_tumbles;
}

int main()
{
    //region mock
//    stringstream cin;
//    cin << "53 5\n"
//           "036552005474503316045244671230763257003205014454317576646651415104774736246223373530313543560352164675733542160416774256562757577303267565012230756331362352034623360206073524577272542727226442237112601327613774057747725750341340753703545317067320271760727065756551547627517027756041053372433206524506305322662235721143776644653261365351545655002362143663425275352313534465104446036610600643036025772116355212061200241173664361043257311542104115720766553324425510464301637020654061515334351050457145403553442710724323272370165061645576562621353341046006465300722065367354371476040217304462317524626601116071471704311723534624446517016162546173154627355536105332145302452666667052741627742567041144634255113226074163450446340730577023251132562517764132661643634561101441605234725545672745147604047344107476323035165312334227520113715470352043224655552333531070060723733560137766353333476227620573710253513265475317654630057735435711244616721716003013704331332524464463622072302160525633656622276147130635210036151214373652774273660761320071053620621133557625334726662556436641742653246703131246066013553507376333015270160553757012763260125267743524524636030372645535203666750146610307147510144326347611134441256264766060726753173071641152023702530047241137740756725637666606025473241622520615527123673042600110346506536722372313355225463517175657475547503115103401362664075702426242144651613520651506777122360441166024773013444547461651724534302031343001147716263700252434406137523477300047534766512053651416524721362034205354172626744241146174301440216722041206622536315466023562476472430030006430603117002270204432726026454520035276670450431423020741205736652401724750355312225133510031717076564744555057350261100720427166027015615375177604577601164757003403444352471033655143723650320252674114315570223754537624102150012732443540551117225757056221102550141204076031570772177453344431514243705133567727310524640054624235456547520216717561536731021652540536375230055371650406261061745601110745003265216067544444550112227770343064763221111673171606516155512047663603130016501071257373376402305013340130367622760227271407353523022000701475236314772534000346752201356232615163574234002630675714211336714702060516663206015110067475047513142646330257055000277455200325061130657337316317554376162466055136155274054476145533163236466107467336747076613717223002745577657411627407725276747074567060763043646607724505664204427301661240615063577147445710213104031553504657301763373331262703553741317134271442306507670012276121100274304637243725253513214504246357470101416140032612206630415515123255662054100130013566517065461265407541006505531506707750631246524223542615004553564176641330356441502623631557520643635125022232750152112551576134720555414646530356414333546343723476573247167126166434111020045433364714613466022126163200737703664610034454501242354610660337744704732722736550631174224525627522620712231533253256744620435613663510675530565660636054015747727625204411141040701232260266324521361202704763406601210112636215103441353253031446312064451667417607145634430554561724211275363376756226272721514200415627737551614517560665643277776441366327407654272157735001157106744167475466657043537136066555562660774237250201512633010775404740262123501065250127473765550533045555740006355107070740045574766254354421774141716702051007035611103530567512220545040074203422355563562122577015565733135641377544727131474400533003316156434711750132507255503150625067041703333055757674071757660225173744650453543114705213253542074342640374204637310673460330374535070164174431727624324516252171644520355540417022403570353471127310176532661233043322177303137126101321532156631432760650705762422032636077130264643442716315175643750152013210665523346471047174003565736167173371504066137551633654255346563154367172465053317211533211545567276724767710047310503416674564751067127275053616001711644073225554250206115422671666204650143500277735400617472506327254661072236765413611213102743733715031404722155440022612574343350047603560515262276270437362305254516652017432742517671260073527064473216267173565511412605463176710343364471056641717311545145157037623411453260366064640633676714025772154736533152426253026771221625361631603466760444357706447144056565217225215450341432533136543670514756662324251711533713203013363740726411556072045307041021542331316160313436115016512506621713730672650273727213217135716064667326256170515764303344077024012231023100566264445374176356265152321170114463602432641517057661415512556046557411537512765577526554132654375524406675222306352325415150514321275503101277135423312150026713511432175572430001266173720271556443341134021562304331755716335451000227463526604422624033677623422124007637116336172346302205435713652021444620603066132311211054752010670235114733377751170700274114400654647567701714707160077141614437337570145366005401763532706420555772112544230356263715766037202021002643271675641424227607222405551224615156147513130716523306671341016352574273642202646071143443503662163165315200612501550461711373445675667361401725575065104535667412115722276340725623405060104117211372271057471721043201614773666744607020015421531071560203234776074501361400361036463660662172147607201462303020711563147517061631071433300531245210103132642112314104716321737773412725670634132565723076315625743207317065572360542674020662317753611274027557261442604770042022341653525077652026110217527243752317571526455306130443142353531513446665030046013635713616742556514345607516252623010131772346406366505126555326320212747764025322210676352724531633661116256736431565514640072033461166331506406605200032063427073710133213437677044347124443752127460654365072270512314644757023650423774066311014735413255226066763535651741611770210151171270060512554461207412630206256717660223510651517372532615134643170764260370235357774757573625415441043422752776341467403610127372203663757576775441443566432516175237464134072201251141230027735555324732012253710400025576773022016134705512211346056662746225563321404530402723321124045454312446263064450702057710703763043601001356234030540342630445420461773475524455605427050407265155516715556037444722011633634442275554137170577305721625614665603434474465320673700052405440701241565333651100636357214244313760164021241541233264624453147021032637237454505071025205217304415672345117273737325073356224235034334373637025551213237331243302674176164247005177532340650401543045310554471312127460651542701745223555723643105510077643071753755420141676317615775750550770033314550215361305523571016125357651712564130772652366126651176765517522004275757676565564326142350011376521354472337400530535214654230430750303412633206544517042411414222233312560342544143313617623656515625777303472342060410751325633262252342423762756136562576237067647104044637007332055516007564156702776157355477432746314101102032767722131574757066157527046375674164116442307204202123326203403404477544411377450443317347541563660021053764221624253735547447652131352660676541753355451656654434570473347144524244661112127760723132020556005470657210250376676565512043573473142306241742224140621226415551145214253714536030156055350051601423062607236571245027432451146455371744235007712343121447035023507726157776500115707370050512271211474506632657305457307260523306307532362255124760346246115457600531231617673671111660040056002157556064326634303602763564545135022074537704601333324577554306555741415152264210116206255411642213164671635574111431454655203255420570570401754561535777444447160634220256601514030111010332441145100046247102003124702146455151532550246173024117247675073664640561560112445705064766021103124575715030441672614451710520027746057147602150327130700214046032615516170043123270112330421604647642473251543656725677662542022146605214515035221063751253300443650701106165631531771353022417624147554746450337773647607170432421365324016552576457447427737200345443303241445120066000405343005750726204232120410154143514765050044127574147533527415004501305321565420562170763313272363544044437606410541246123666641377436413747557274733654517007643561431451250405211033245012010507167200326541235640037322213751413752601272665743755174400517223746457665436715256216307050360530074664660606322705153533411451246330225541722126316456424706732263061457553733554440234132542547166446724245016650501760170536035736617263400716451211050160635052747314207144515772265351243570574027165160747656022365422446632756473162201467075025315663654510224326246752677640375277376726607441043637300411767076626310777756161514275514523154111503662653302110533154356373043377156341613735747730412616062725553502526712132724723753753143366045741727237404756342727013443552157703435145333766605240573252050433447577505661740304645424306763646572305637227012332362467447410232022105305611045345353431027615702020672124020736646311231656357345746065245011606315437124322275207057021546436415132612607601003705252023306726704215672021007201664150171140164742342755651652566555063307255543051067027205070437614001524531003376645163563760643603025401640721110300154533004202433433427621513574040714611633457373001235350274541311655545706350536617772677664037136233560672147506360717265300303260474417416266443037501273073323766607203245661276055137716051622705400676534374735123563015156070416607020520017600176101514725260645242004153622442116205027174444425675466754123053633270332737527415407474220712276170432411705560512731425145361555326421567477464714443567164175714401756005415634032516254202746210262706345246366703264575400176467523315213467757653172244353441013646644504100744115672072605364346725552014561715306621162717262431700726071761311444216160650651310265560607231472567062602747264636370142025230671361254246023160126570417064746\n"
//           "#.....#...#.#.......#...#...#.#.....#...#.#...#.#....\n"
//           "#.....#...#.#.......#...#...#.#..#..#...#.#...#.#....\n"
//           "#.....#...#.#...#...#...#...#.#.##..#...#.#...#.###..\n"
//           "#####.#####.#####.#####.#...#.#####.#####.#...#.#####\n"
//           "#####.#####.#####.#####.#####.#####.#####.#####.#####";
    // stringstream cin;
    // cin << "17 5\n"
    //       "1\n"
    //       ".................\n"
    //       ".................\n"
    //       "...##...###..#...\n"
    //       ".####..#####.###.\n"
    //       "#################";

    //endregion

    int columns;
    int rows;
    cin >> columns >> rows; cin.ignore();
//    string centrifuge_command; getline(cin, centrifuge_command);
    int tumblings_count; cin >> tumblings_count; cin.ignore();

    auto* row_block_counts = new vector<int>(rows, 0);
    auto* col_block_counts = new vector<int>(columns, 0);

    for (int i = 0; i < rows; i++) {
        string tile_row; getline(cin, tile_row);

        for (int j = 0; j < columns; ++j) {
            if(tile_row.at(j) == '#') {
                row_block_counts->at(i)++;
                col_block_counts->at(j)++;
            }
        }
    }
    //endregion

    Landscape init_landscape(row_block_counts, col_block_counts);
    LandscapeTumbler tumbler(init_landscape);
//
//    long tumblings_count = getNetTumblingsCount(centrifuge_command);

    auto& result_landscape =  tumbler.tumble(tumblings_count);

    auto landscape_char_grid =  result_landscape.toGrid();

    ostream_iterator<char> os_it(cout, "");
    for(auto& row : landscape_char_grid) {
        copy(row.begin(), row.end(), os_it);
        cout << "\n";
    }
}

